Functional Brief: Fix Race Condition in Question Transitions

  Problem Summary

  When the user clicks "Next Question", Alvia sometimes asks a random/irrelevant question instead of the next template question. This occurs because session.update (new instructions) and response.create (trigger speech) are sent back-to-back without waiting for OpenAI to confirm the instructions were applied.

  Root cause: server/voice-interview.ts lines 1183-1199 send session.update followed immediately by response.create. The OpenAI Realtime API may process response.create before applying the new instructions.

  Solution Overview

  Implement a critical section around question transitions that:
  1. Disables the "Next Question" button during transition
  2. Waits for any pending Barbara analysis to complete
  3. Sends session.update and waits for session.updated confirmation
  4. Only then sends response.create
  5. Re-enables the button

  Implementation Details

  1. Add new state fields

  In InterviewState interface (around line 26):

  isTransitioningQuestion: boolean;
  pendingTransitionResolve: (() => void) | null;

  Initialize in state object (around line 256):

  isTransitioningQuestion: false,
  pendingTransitionResolve: null,

  2. Update session.updated handler

  In handleOpenAIEvent, case session.updated (around line 651):

  After the existing isInitialSession check, add:

  // Resolve pending question transition if waiting
  if (state.isTransitioningQuestion && state.pendingTransitionResolve) {
    state.pendingTransitionResolve();
    state.pendingTransitionResolve = null;
  }

  3. Block Barbara during transitions

  In triggerBarbaraAnalysis function (around line 812), add early return:

  async function triggerBarbaraAnalysis(sessionId: string, clientWs: WebSocket): Promise<BarbaraGuidance | null> {
    const state = interviewStates.get(sessionId);
    if (!state || state.isWaitingForBarbara) return null;

    // Skip Barbara during question transitions - guidance would be stale
    if (state.isTransitioningQuestion) {
      console.log(`[Barbara] Skipping analysis during question transition`);
      return null;
    }

    // ... rest of function
  }

  4. Rewrite next_question handler

  Replace the entire case "next_question": block (lines 1118-1260) with a serialized async flow:

  case "next_question":
    // Prevent concurrent transitions
    if (state.isTransitioningQuestion) {
      console.log(`[VoiceInterview] Ignoring next_question - transition in progress`);
      return;
    }

    if (state.currentQuestionIndex >= state.questions.length - 1) {
      clientWs.send(JSON.stringify({ type: "interview_complete" }));
      return;
    }

    // Execute transition in async IIFE
    (async () => {
      state.isTransitioningQuestion = true;

      // Notify client to disable button and show waiting state
      clientWs.send(JSON.stringify({
        type: "question_transition_started",
        message: "Moving to next question..."
      }));

      try {
        // 1. Wait for any pending Barbara analysis (max 10s)
        if (state.isWaitingForBarbara) {
          console.log(`[VoiceInterview] Waiting for pending Barbara analysis...`);
          await new Promise<void>((resolve) => {
            const checkInterval = setInterval(() => {
              if (!state.isWaitingForBarbara) {
                clearInterval(checkInterval);
                resolve();
              }
            }, 100);
            setTimeout(() => {
              clearInterval(checkInterval);
              console.log(`[VoiceInterview] Barbara wait timeout, proceeding`);
              resolve();
            }, 10000);
          });
        }

        // 2. Update question index and capture snapshots
        const previousIndex = state.currentQuestionIndex;
        state.currentQuestionIndex++;
        const targetQuestionIndex = state.currentQuestionIndex;
        const targetQuestion = state.questions[targetQuestionIndex];
        const summariesSnapshot = [...state.questionSummaries.filter(s => s != null)];
        const templateSnapshot = state.template;

        // Initialize metrics for new question
        state.questionMetrics.set(targetQuestionIndex, createEmptyMetrics(targetQuestionIndex));
        state.lastBarbaraGuidance = null;

        // 3. Generate summary for previous question (non-blocking)
        generateAndPersistSummary(sessionId, previousIndex).catch(() => {});

        // Persist question state changes
        persistNextQuestion(sessionId, previousIndex, targetQuestionIndex);

        // 4. Analyze topic overlap (blocking, max 8s timeout built-in)
        let topicOverlap: TopicOverlapResult | undefined;
        try {
          topicOverlap = await analyzeTopicOverlap(
            {
              text: targetQuestion?.questionText || "",
              guidance: targetQuestion?.guidance || "",
            },
            targetQuestionIndex,
            summariesSnapshot,
            templateSnapshot?.objective || "",
          );
        } catch (error) {
          console.error(`[VoiceInterview] Topic overlap analysis failed:`, error);
        }

        // 5. Build instructions with topic overlap context
        const instructions = buildInterviewInstructions(
          templateSnapshot,
          targetQuestion,
          targetQuestionIndex,
          state.questions.length,
          undefined,
          topicOverlap,
        );

        // 6. Send session.update and wait for confirmation
        if (state.openaiWs && state.openaiWs.readyState === WebSocket.OPEN) {
          const sessionUpdatePromise = new Promise<void>((resolve) => {
            state.pendingTransitionResolve = resolve;
            // Timeout fallback after 5 seconds
            setTimeout(() => {
              if (state.pendingTransitionResolve === resolve) {
                console.warn(`[VoiceInterview] session.updated timeout, proceeding anyway`);
                state.pendingTransitionResolve = null;
                resolve();
              }
            }, 5000);
          });

          state.openaiWs.send(JSON.stringify({
            type: "session.update",
            session: { instructions: instructions },
          }));

          await sessionUpdatePromise;

          // 7. Now safe to trigger response
          state.openaiWs.send(JSON.stringify({
            type: "response.create",
            response: { modalities: ["text", "audio"] },
          }));
        }

        // 8. Notify client about topic overlap if detected
        if (topicOverlap?.hasOverlap) {
          clientWs.send(JSON.stringify({
            type: "topic_overlap_detected",
            questionIndex: targetQuestionIndex,
            overlapSummary: topicOverlap.overlapSummary,
          }));
        }

        // 9. Notify client of question change
        clientWs.send(JSON.stringify({
          type: "question_changed",
          questionIndex: targetQuestionIndex,
          totalQuestions: state.questions.length,
          currentQuestion: targetQuestion?.questionText,
        }));

      } finally {
        // Always re-enable transitions
        state.isTransitioningQuestion = false;
        state.pendingTransitionResolve = null;

        clientWs.send(JSON.stringify({
          type: "question_transition_complete"
        }));
      }
    })();
    break;

  5. Client-side changes

  In the interview UI component (likely client/src/pages/Interview.tsx or similar), handle the new WebSocket messages:

  // Handle question_transition_started
  case "question_transition_started":
    setIsTransitioning(true);  // Disable "Next Question" button
    // Optionally show toast: "Moving to next question..."
    break;

  // Handle question_transition_complete  
  case "question_transition_complete":
    setIsTransitioning(false);  // Re-enable button
    break;

  The "Next Question" button should be disabled when isTransitioning === true:

  <Button
    onClick={handleNextQuestion}
    disabled={isTransitioning || isLastQuestion}
  >
    {isTransitioning ? "Please wait..." : "Next Question"}
  </Button>

  Testing Checklist

  1. Basic flow: Click "Next Question" → button disables → Alvia asks correct next question → button re-enables
  2. Rapid clicks: Click multiple times quickly → only one transition occurs
  3. Mid-speech transition: Speak, then immediately click "Next Question" → transition waits for Barbara, then proceeds
  4. Topic overlap: When next question overlaps with prior answers, Alvia should acknowledge prior context
  5. Timeout handling: If OpenAI is slow (>5s), transition should still complete with warning logged
  6. Final question: Clicking on last question should show "interview_complete", not error

  Files to Modify

  - server/voice-interview.ts - Main implementation
  - client/src/pages/Interview.tsx (or equivalent) - Button disable state